. .\CI\CI_Utils_2008R2.ps1  | out-null

$sts = get-module | select-string -pattern HyperV -quiet
if (! $sts)
{
	"Import the module of HyperV.psd1"
    Import-module .\BIS\WS2008R2\lisa\HyperVLibV2Sp1\Hyperv.psd1
}

#DebugParameterEnable is true for debug when the test is lanched from localhost replaces of Jenkins job 
$DebugParameterEnable = $False
if( $DebugParameterEnable -eq $True )
{
	$env:VMName = "FreeBSD11"
	$env:TestSuite = "Debug"
}




<#
$xml: xml file path
$scriptFile: The file will be executed on VM
$remoteDir: This directory on VM is stored the files from the local
$toolsParentDir: This directory on local is the parent directory of tools subdirectory
$scriptFilePara: The parameters for script file 
$logFileOnVM: The log name generated by the script on VM
$logFileDirOnLocal: This directory is stored the log copied from VM 
$timeout: The script file must be done in this time

Example:
$remoteDir = "/tmp"
$logFile = "autobuild.log"
ExecuteScriptFromLocalToVmAndCheckResult  "$pwd\BIS\$os_on_host\lisa\run.xml" "./CI/autobuildtest.sh" $remoteDir  "CI" " --buildworld --srcURL https://svn.FreeBSD.org/base/ --log $remoteDir/$logFile " "$remoteDir/$logFile"  $pwd  "3600"
#>
Function ExecuteScriptFromLocalToVmAndCheckResult ( [String]$xml,[String]$scriptFile,[String]$remoteDir,[String]$toolsParentDir,[String]$scriptFilePara,[String]$logFileOnVM,[String]$logFileDirOnLocal,[String]$timeout)
{

	$xmlFilenameForVM = [xml] (Get-Content -Path  $xml)  2>null
	$vm = $xmlFilenameForVM.config.VMs.vm

	cd .\$toolsParentDir
	WaitSSHLoginPrepare $vm.sshKey  $vm.ipv4 
	cd ..
	
	#Send the script from local to VM
	$sts = SendFileToVMUntilTimeout  $vm $scriptFile $remoteDir $toolsParentDir 
	if( $sts -ne 0 )
	{
		LogMsg 0 "Error: $($vm.vmName) send $scriptFile to $($vm.vmName) failed"
		return 1
	}
	
	LogMsg 10 "Log: $($vm.vmName) send $scriptFile to $($vm.vmName) successfully"

	#Send command from local host to VM 
	#Make sure the format of script on VM is unix 
	$fileName = [io.path]::GetFileName("$scriptFile")
	$FreeBSDFileName = "$remoteDir/$fileName"
	LogMsg 10 "Info: To set the format of script $FreeBSDFileName on $($vm.vmName) being unix"
	if (-not (SendCommandToVMUntilTimeout $vm "dos2unix  $FreeBSDFileName" $toolsParentDir "120") )
	{
		LogMsg 0 "Error: Unable to set the format of script $FreeBSDFileName on $($vm.vmName) being unix"
		return 1
	}
	LogMsg 10 "Log: Set the format of script $FreeBSDFileName on $($vm.vmName) being unix successfully"
	
	#To set x bit of the script on VM
	LogMsg 10  "Info: To set x bit of the script $FreeBSDFileName on $($vm.vmName)"
	if (-not (SendCommandToVMUntilTimeout $vm "chmod 755 $FreeBSDFileName"  $toolsParentDir "120") )
	{
		LogMsg 0 "Error: $($vm.vmName) unable to set x bit on test $FreeBSDFileName script"
		return 1
	}


	#Send command to run script on VM 
	#Note: This script will reboot the VM !!!
	LogMsg 10 "Info: To run the script $FreeBSDFileName on $($vm.vmName) for Syncing, building and installing kernel/world"
	LogMsg 10 "Info: This step will take a very long time ..."
	if (-not (SendCommandToVMUntilTimeout $vm "$FreeBSDFileName  $scriptFilePara"  $toolsParentDir $timeout) )
	{
		LogMsg 0  "Error: $($vm.vmName) unable to run $FreeBSDFileName script"
		return 1
	} 

	LogMsg 10  "Info: The former step will reboot the VM, so please wait VM boot completely"
	LogMsg 10  "Info: It will takes more than one minute, please wait with patience"
	$sts = WaitVMBootFinish $vm 
	if( $sts -ne 0 )
	{
		return 1
	}

	#Get log file from VM to local host		
	LogMsg 10  "Info: Get log file $logFileOnVM from VM to local host"
	$sts = GetFileFromVMUntilTimeout  $vm $logFileOnVM $logFileDirOnLocal  $toolsParentDir   
	if( $sts -ne 0 )
	{
		LogMsg 0 "Error: $($vm.vmName) get $logFileOnVM from $($vm.vmName) failed"
		return 1
	}
	
	$name = [io.path]::GetFileName("$logFileOnVM")
	$sts = CheckErrorLogInFile "$logFileDirOnLocal\$name"
	if( $sts -ne 0 )
	{
		LogMsg 0 "Error: There is some errors in $logFileDirOnLocal\$name"
		return 1
	}

	return 0

}


Function CIUpdateConfig([string]$originalConfigFile, [string]$CIFolder, [string]$newConfigFileName)
{
	<#
	Usage:
		CIUpdateConfig $originalConfigFile $CIFolder $newConfigFileName
	Description:
		This is a function to update cloud configuration for CI job.
	#>
	
	$newConfigFile = "$CIFolder\$newConfigFileName"
    
    # The $newConfigFileName is a copy of $originalConfigFile. All changes will be written into the $newConfigFileName
	"Copy $originalConfigFile to $newConfigFile"
    Copy-Item $originalConfigFile $newConfigFile

	"Begin to update the parameters of vm name, test suite, ip address and so on."
	[xml]$xml = Get-Content "$newConfigFile"
	
	# Update parameter of OnGuestReadHostKvpData test case
	# TODO
	
	# Update vmName
	$xml.config.VMs.vm.vmName = $env:VMName
	
	# Update test suite
	$xml.config.VMs.vm.suite = $env:TestSuite
	
	# Update test hvServer
	$server = "localhost"
	$xml.config.VMs.vm.hvServer = $server
	
	# Update ipv4 address
	$ipv4_addr = GetIPv4 $env:VMName $server
    if( $ipv4_addr -eq $null -or $ipv4_addr -eq "" -or $ipv4_addr -eq " " )
    {
        "Error: Update IPv4 address failed."
        return 1
    }
	$xml.config.VMs.vm.ipv4 = [string]$ipv4_addr

	if($env:DebugCases -and $env:DebugCases.Trim() -ne "")
	{
		$debugCycle = $xml.SelectSingleNode("/config/testSuites/suite[suiteName=`"debug`"]")
		if($debugCycle)
		{
			foreach($testcase in $debugCycle.suiteTests)
			{
				$testcase = $debugCycle.RemoveChild($testcase)
			}
		}
		else
		{
			$debugCycle = $xml.CreateElement("suite")
			$name = $xml.CreateElement("suiteName")
			$name.InnerText = "DEBUG"
			$name = $debugCycle.AppendChild($name)
			$debugCycle = $xml.DocumentElement.testSuites.AppendChild($debugCycle)
		}
		
		$debugCase = $xml.CreateElement("suiteTests")
		foreach($cn in ($env:DebugCases).Trim().Split(","))
		{
			$debugCaseName = $xml.CreateElement("suiteTest")
			$debugCaseName.InnerText = $cn.Trim()
			$debugCaseName = $debugCase.AppendChild($debugCaseName)
			$debugCase = $debugCycle.AppendChild($debugCase)
		}
	}

	$xml.Save("$newConfigFile")
    
    return 0
}

"`n`n"
"#############################################################"
"`n"
"CI job name: $env:JOB_NAME"
"VM name: $env:VMName"
"Test suite: $env:TestSuite"
"Git URL: $env:SoureCodeURL"
"Git branch: $env:GitBranch"
"`n"
"#############################################################"
"`n`n"

"Begin to prepare the xml for test"

# Copy certificate
$os_on_host = "WS2008R2"
$sshDir = "$pwd" +"\BIS\$os_on_host\lisa\ssh"
$status = Test-Path $sshDir  
if( $status -ne "True" )
{
	New-Item  -ItemType "Directory" $sshDir
}
"To copy certificate"
Copy-Item CI\ssh\*   $sshDir

$global:testReport = "$pwd\CI\report.xml"
$status = Test-Path $testReport  
if( $status -eq "True" )
{
	"Delete the old $testReport"
	Remove-Item   $testReport  -Force
}

$global:reportCompressFile = "$pwd\CI\logs.zip"
$status = Test-Path $reportCompressFile  
if( $status -eq "True" )
{
	"Delete the old $reportCompressFile"
	Remove-Item  $reportCompressFile  -Force
}

# Copy tools
$binDir = "$pwd" + "\BIS\$os_on_host\lisa\bin"
$status = Test-Path $binDir 
if( $status -ne "True" )
{
	New-Item  -ItemType "Directory" $binDir
}
"To copy tools"
Copy-Item CI\tools\*   $binDir


"The vm name is:  $env:VMName"
#Delete the snapshort
$sts = DeleteSnapshot $env:VMName "localhost"
if($sts -eq 1)
{
	"The expected return value  is 0, but it's $sts."
	return 1
}

"Now, it begins to start the $env:VMName vm and please wait for a moment..."
$sts = DoStartVM $env:VMName "localhost"
if($sts -eq 1)
{
	"The expected return value  is 0, but it's $sts."
	return 1
}

"Begin to update the xml config for CI test"
$XmlConfigFile = "FreeBSD_WS2008R2.xml"
if ($XmlConfigFile -and (Test-Path "$pwd\BIS\$os_on_host\lisa\xml\freebsd\$XmlConfigFile"))
{
	$sts = CIUpdateConfig "$pwd\BIS\$os_on_host\lisa\xml\freebsd\$XmlConfigFile" "$pwd\BIS\$os_on_host\lisa" run.xml 
    if( $sts[-1] -ne 0 )
    {
        "Failed to prepare the $pwd\BIS\$os_on_host\lisa\run.xml and abort the test."
        return 1
    }
}
else
{
	#TODO
	return 1
}

"Update the xml config for CI test done."

#Begin to build and install kernel/world if necessary
$remoteDir = "/usr"
$logFile = "autobuild.log"
$branch = $env:GitBranch
$bisCodeDir = "BIS"
$ciCodeDir = "CI"
$env:BuildWorld = $False
$env:BuildKernel = $True

if( $env:SoureCodeURL -eq $null -or $env:SoureCodeURL -eq "" -or $env:SoureCodeURL -eq " " )
{
	$env:BuildKernel = $False
}

if( $env:BuildWorld -eq $True )
{
    "Begin to build and install world&kernel and it will take a very long time ..."
	$sts=ExecuteScriptFromLocalToVmAndCheckResult  ".\$bisCodeDir\$os_on_host\lisa\run.xml" ".\$ciCodeDir\autobuild.sh" $remoteDir  $ciCodeDir " --buildworld  -b $branch  --srcURL $env:SoureCodeURL --log $remoteDir/$logFile " "$remoteDir/$logFile"  $pwd  "36000"
	if($sts -eq 1)
	{
		"The expected return value  is 0, but it's $sts."
		"Build & install world&kernel failed"
		"----------------------- Log from vm -----------------------"
		Get-Content $logFile
		return 1
	}
}
elseif( $env:BuildKernel -eq $True )
{
    "Begin to build and install kernel and it will take a long time ..."
	$sts=ExecuteScriptFromLocalToVmAndCheckResult  ".\$bisCodeDir\$os_on_host\lisa\run.xml" ".\$ciCodeDir\autobuild.sh" $remoteDir  $ciCodeDir " -b $branch --srcURL $env:SoureCodeURL --log $remoteDir/$logFile " "$remoteDir/$logFile"  $pwd  "108000"
	if($sts -eq 1)
	{
		"The expected return value  is 0, but it's $sts."
		"Build & install kernel failed"
		"----------------------- Log from vm -----------------------"
		Get-Content $logFile
		return 1
	}
}



#To stop the vm before creating a snapshort
$sts = DoStopVM $env:VMName "localhost"
if($sts -eq 1)
{
	"The expected return value  is 0, but it's $sts."
	"Warning: Stop the vm failed before creating a snapshort."
}

#Create a snapshort named "ICABase" before test cases
$sts=CreateSnapshot $env:VMName "localhost"  "ICABase"
if($sts -eq 1)
{
	"The expected return value  is 0, but it's $sts."
	"Warning: Create snapshort failed before runnig test cases."
}

"Begin to add 3 passthrough disks in Computer Management for Pass Through Drive feature test."
$HyperVDir = "C:\Users\Public\Documents\Hyper-V\Virtual hard disks\"
$sts = AddPassThroughDisks  $HyperVDir "localhost"
if( $sts -ne 0 )
{
	"Add passthrough disks in Computer Management failed."
	"Warning: The test will be continued, but some test cases based on passthrough disks will be failed."
}
else
{
	"Add 3 passthrough disks in Computer Management successfully."
}



#Now, everything is OK and begins to run the test cases
"Ready to run test cases"
cd .\BIS\$os_on_host\lisa
.\lisa run run.xml
"Run test cases done"



